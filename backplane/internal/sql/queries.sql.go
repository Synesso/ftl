// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: queries.sql

package sql

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const associateArtefactWithDeployment = `-- name: AssociateArtefactWithDeployment :exec
INSERT INTO deployment_artefacts (deployment_id, artefact_id)
VALUES ($1, $2)
`

type AssociateArtefactWithDeploymentParams struct {
	DeploymentID int64
	ArtefactID   int64
}

func (q *Queries) AssociateArtefactWithDeployment(ctx context.Context, arg AssociateArtefactWithDeploymentParams) error {
	_, err := q.db.Exec(ctx, associateArtefactWithDeployment, arg.DeploymentID, arg.ArtefactID)
	return err
}

const createArtefact = `-- name: CreateArtefact :one
WITH new_artefact AS (
  INSERT INTO artefacts (executable, path)
  VALUES ($1, $2)
  RETURNING id AS artefact_id
)
INSERT INTO artefact_contents (artefact_id, digest, content)
VALUES ((SELECT artefact_id FROM new_artefact), $3, $4)
RETURNING artefact_id
`

type CreateArtefactParams struct {
	Executable bool
	Path       string
	Digest     []byte
	Content    []byte
}

// Create a new artefact and return the artefact ID.
func (q *Queries) CreateArtefact(ctx context.Context, arg CreateArtefactParams) (int64, error) {
	row := q.db.QueryRow(ctx, createArtefact,
		arg.Executable,
		arg.Path,
		arg.Digest,
		arg.Content,
	)
	var artefact_id int64
	err := row.Scan(&artefact_id)
	return artefact_id, err
}

const createDeployment = `-- name: CreateDeployment :one
INSERT INTO deployments (module_id, "schema")
VALUES ((SELECT id FROM modules WHERE name = $1::TEXT LIMIT 1), $2::BYTEA)
RETURNING id
`

type CreateDeploymentParams struct {
	ModuleName string
	Schema     []byte
}

func (q *Queries) CreateDeployment(ctx context.Context, arg CreateDeploymentParams) (int64, error) {
	row := q.db.QueryRow(ctx, createDeployment, arg.ModuleName, arg.Schema)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createModule = `-- name: CreateModule :one
INSERT INTO modules (language, name) VALUES ($1, $2)
ON CONFLICT (name) DO UPDATE SET language = $1
RETURNING id
`

type CreateModuleParams struct {
	Language string
	Name     string
}

func (q *Queries) CreateModule(ctx context.Context, arg CreateModuleParams) (int64, error) {
	row := q.db.QueryRow(ctx, createModule, arg.Language, arg.Name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getArtefactDigests = `-- name: GetArtefactDigests :many
SELECT digest FROM artefact_contents WHERE digest = ANY($1::text[])
`

// Return the digests that exist in the database.
func (q *Queries) GetArtefactDigests(ctx context.Context, digests []string) ([][]byte, error) {
	rows, err := q.db.Query(ctx, getArtefactDigests, digests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var digest []byte
		if err := rows.Scan(&digest); err != nil {
			return nil, err
		}
		items = append(items, digest)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArtefactsForDeployment = `-- name: GetArtefactsForDeployment :many
SELECT id, created_at, executable, path, deployment_id, deployment_artefacts.artefact_id, artefact_contents.artefact_id, digest, content FROM artefacts
INNER JOIN deployment_artefacts ON artefacts.id = deployment_artefacts.artefact_id
INNER JOIN artefact_contents ON artefacts.id = artefact_contents.artefact_id
WHERE deployment_id = $1
`

type GetArtefactsForDeploymentRow struct {
	ID           int64
	CreatedAt    pgtype.Timestamp
	Executable   bool
	Path         string
	DeploymentID int64
	ArtefactID   int64
	ArtefactID_2 int64
	Digest       []byte
	Content      []byte
}

func (q *Queries) GetArtefactsForDeployment(ctx context.Context, deploymentID int64) ([]GetArtefactsForDeploymentRow, error) {
	rows, err := q.db.Query(ctx, getArtefactsForDeployment, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArtefactsForDeploymentRow
	for rows.Next() {
		var i GetArtefactsForDeploymentRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Executable,
			&i.Path,
			&i.DeploymentID,
			&i.ArtefactID,
			&i.ArtefactID_2,
			&i.Digest,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeploymentArtefacts = `-- name: GetDeploymentArtefacts :many
SELECT created_at, executable, path, content
FROM artefacts
INNER JOIN deployment_artefacts ON artefacts.id = deployment_artefacts.artefact_id AND deployment_artefacts.deployment_id = $1
INNER JOIN artefact_contents ON artefacts.id = artefact_contents.artefact_id
WHERE deployment_id = $1
`

type GetDeploymentArtefactsRow struct {
	CreatedAt  pgtype.Timestamp
	Executable bool
	Path       string
	Content    []byte
}

// Get all artefacts matching the given digests.
func (q *Queries) GetDeploymentArtefacts(ctx context.Context, deploymentID int64) ([]GetDeploymentArtefactsRow, error) {
	rows, err := q.db.Query(ctx, getDeploymentArtefacts, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeploymentArtefactsRow
	for rows.Next() {
		var i GetDeploymentArtefactsRow
		if err := rows.Scan(
			&i.CreatedAt,
			&i.Executable,
			&i.Path,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestDeployment = `-- name: GetLatestDeployment :one
SELECT deployments.id, deployments.created_at, deployments.module_id, deployments.key, deployments.schema, modules.language, modules.name AS module_name FROM deployments
INNER JOIN modules ON modules.id = deployments.module_id
WHERE modules.name = $1
ORDER BY created_at DESC LIMIT 1
`

type GetLatestDeploymentRow struct {
	ID         int64
	CreatedAt  pgtype.Timestamp
	ModuleID   int64
	Key        uuid.UUID
	Schema     []byte
	Language   string
	ModuleName string
}

func (q *Queries) GetLatestDeployment(ctx context.Context, moduleName string) (GetLatestDeploymentRow, error) {
	row := q.db.QueryRow(ctx, getLatestDeployment, moduleName)
	var i GetLatestDeploymentRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.ModuleID,
		&i.Key,
		&i.Schema,
		&i.Language,
		&i.ModuleName,
	)
	return i, err
}

const listDeployments = `-- name: ListDeployments :many
SELECT id, created_at, module_id, key, schema FROM deployments WHERE module_id = $1
`

func (q *Queries) ListDeployments(ctx context.Context, moduleID int64) ([]Deployment, error) {
	rows, err := q.db.Query(ctx, listDeployments, moduleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Deployment
	for rows.Next() {
		var i Deployment
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.ModuleID,
			&i.Key,
			&i.Schema,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModules = `-- name: ListModules :many
SELECT id, language, name FROM modules
`

func (q *Queries) ListModules(ctx context.Context) ([]Module, error) {
	rows, err := q.db.Query(ctx, listModules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Module
	for rows.Next() {
		var i Module
		if err := rows.Scan(&i.ID, &i.Language, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
